<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Neon Rain</title>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: #050505; /* 深夜背景 */
        }
        canvas {
            display: block;
        }
        #instructions {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: rgba(255, 255, 255, 0.6);
            font-family: sans-serif;
            font-size: 14px;
            pointer-events: none; /* 让鼠标事件穿透文字 */
            text-align: center;
            text-shadow: 0 0 5px rgba(0,0,0,0.8);
            z-index: 10;
        }
    </style>
</head>
<body>

    <div id="instructions">
        左右移动鼠标改变风向 • 鼠标周围有避雨力场
    </div>
    <canvas id="rainCanvas"></canvas>

    <script>
        const canvas = document.getElementById('rainCanvas');
        const ctx = canvas.getContext('2d');

        let width, height;
        let drops = [];
        let splashes = []; // 存储飞溅粒子
        // 雨滴数量，可以根据性能调整。2000属于比较大的暴雨
        const dropCount = 2000; 
        
        // 全局时间变量，用于颜色循环
        let tick = 0;
        
        // 鼠标交互状态
        const mouse = {
            x: -1000, // 初始位置在屏幕外
            y: -1000,
            active: false
        };

        // 风力系数
        let wind = 0;

        // 初始化画布尺寸
        function resize() {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;
        }

        // 飞溅粒子类
        class Splash {
            constructor(x, y, hue) {
                this.x = x;
                this.y = y;
                // 随机向左右飞溅，速度随机
                this.vx = (Math.random() - 0.5) * 4; 
                // 向上弹起，速度随机
                this.vy = -(Math.random() * 3 + 2); 
                this.gravity = 0.2;
                this.hue = hue; // 继承雨滴的颜色
                this.life = 1.0; // 生命周期/透明度
                this.decay = Math.random() * 0.05 + 0.02; // 消失速度
            }

            update() {
                this.x += this.vx;
                this.vy += this.gravity;
                this.y += this.vy;
                this.life -= this.decay;
            }

            draw() {
                // 使用 HSLA 颜色
                ctx.fillStyle = `hsla(${this.hue}, 100%, 70%, ${this.life})`;
                ctx.beginPath();
                ctx.arc(this.x, this.y, 1, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        // 雨滴类
        class Drop {
            constructor() {
                this.reset(true);
            }

            // 重置雨滴属性
            reset(initial = false) {
                this.x = Math.random() * width;
                // 如果是初始化，随机分布在全屏；否则从顶部开始
                this.y = initial ? Math.random() * height : -50;
                
                // z轴深度 (0 - 1)，1离屏幕最近，0最远
                this.z = Math.random(); 
                
                // 调整参数让雨看起来更细腻
                this.len = 15 + this.z * 15; 
                this.opacity = 0.1 + this.z * 0.4; 
                this.speed = 8 + this.z * 12; 
                this.width = 0.5 + this.z * 0.8; 
                
                this.velX = (Math.random() - 0.5) * 0.5;

                // 随机色彩偏移：每个雨滴都有自己的颜色性格
                // 这样即使全局颜色在变，每个雨滴也不是完全一样的颜色
                this.colorOffset = Math.random() * 60; 
            }

            update() {
                // 1. 应用风力
                const windTarget = (mouse.x - width / 2) * 0.02; 
                wind += (windTarget - wind) * 0.001; 
                
                this.x += this.velX + wind * this.z;
                this.y += this.speed;

                // 2. 鼠标排斥力场
                if (mouse.active) {
                    const dx = this.x - mouse.x;
                    const dy = this.y - mouse.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    const forceRadius = 100;

                    if (dist < forceRadius) {
                        const force = (forceRadius - dist) / forceRadius;
                        const angle = Math.atan2(dy, dx);
                        
                        const pushX = Math.cos(angle) * force * 15;
                        const pushY = Math.sin(angle) * force * 15;
                        
                        this.x += pushX;
                        this.y += pushY;
                    }
                }

                // 3. 边界检查
                // 落地逻辑：生成飞溅
                if (this.y > height) {
                    // 只有靠近屏幕的雨滴(z较大)才产生明显飞溅
                    if (this.z > 0.5 && Math.random() > 0.5) {
                        const splashCount = Math.floor(Math.random() * 2) + 1;
                        // 计算当前雨滴的颜色值
                        const currentHue = (tick + this.colorOffset) % 360;
                        for(let i=0; i < splashCount; i++) {
                            splashes.push(new Splash(this.x, height, currentHue));
                        }
                    }
                    this.reset();
                } 
                else if (this.x > width + 100 || this.x < -100) {
                    this.reset();
                    if (this.x > width) this.x = -50;
                    else if (this.x < 0) this.x = width + 50;
                    else this.y = -50;
                }
            }

            draw() {
                ctx.beginPath();
                const tailX = this.x - (this.velX + wind * this.z) * 2;
                const tailY = this.y - this.speed * 1.5;

                ctx.moveTo(this.x, this.y);
                ctx.lineTo(tailX, tailY);
                
                // 动态颜色计算：
                // 基础颜色(tick) + 个人偏移(colorOffset) + 屏幕位置影响(this.x * 0.1)
                // 这创造了一个流动的彩虹效果
                const hue = (tick + this.colorOffset + this.x * 0.1) % 360;
                
                // 使用 HSLA: Hue(色相), Saturation(饱和度), Lightness(亮度), Alpha(透明度)
                ctx.strokeStyle = `hsla(${hue}, 100%, 70%, ${this.opacity})`;
                ctx.lineWidth = this.width;
                ctx.lineCap = 'round';
                ctx.stroke();
            }
        }

        function init() {
            resize();
            for (let i = 0; i < dropCount; i++) {
                drops.push(new Drop());
            }
            animate();
        }

        function animate() {
            // 时间流逝，让颜色动起来
            tick += 0.5;

            // 拖影背景
            ctx.fillStyle = 'rgba(5, 5, 5, 0.4)';
            ctx.fillRect(0, 0, width, height);

            for (let drop of drops) {
                drop.update();
                drop.draw();
            }

            for (let i = splashes.length - 1; i >= 0; i--) {
                let s = splashes[i];
                s.update();
                s.draw();
                if (s.life <= 0) {
                    splashes.splice(i, 1);
                }
            }
            
            if(splashes.length > 1000) {
                splashes.splice(0, splashes.length - 1000);
            }

            // 绘制雨伞和暖心文字
            if (mouse.active) {
                ctx.save();
                ctx.translate(mouse.x, mouse.y);
                
                // 1. 绘制伞盖
                ctx.beginPath();
                // 伞的半圆
                ctx.arc(0, -10, 45, Math.PI, 0); 
                // 伞的底部连接线 (贝塞尔曲线让它看起来有弧度)
                ctx.bezierCurveTo(20, -25, -20, -25, -45, -10);
                
                // 伞的样式 - 暖色调光晕，给人安全感
                ctx.shadowColor = "rgba(255, 220, 150, 0.6)";
                ctx.shadowBlur = 25;
                ctx.fillStyle = "rgba(30, 30, 40, 0.8)"; // 伞身深色半透明
                ctx.fill();
                ctx.strokeStyle = "rgba(255, 255, 255, 0.9)";
                ctx.lineWidth = 2;
                ctx.stroke();

                // 2. 绘制伞柄
                ctx.beginPath();
                ctx.shadowBlur = 0; // 伞柄不需要太多光晕
                ctx.moveTo(0, -20); // 从伞盖内部开始
                ctx.lineTo(0, 35);  // 竖线
                ctx.arc(6, 35, 6, Math.PI, 0); // 弯钩
                ctx.strokeStyle = "rgba(220, 220, 220, 0.8)";
                ctx.lineWidth = 3;
                ctx.stroke();

                // 3. 绘制文字
                ctx.shadowColor = "rgba(0, 0, 0, 0.8)"; // 文字阴影，保证清晰
                ctx.shadowBlur = 4;
                ctx.font = "bold 18px 'Microsoft YaHei', sans-serif";
                ctx.fillStyle = "#ffffff";
                ctx.textAlign = "center";
                // 文字在伞上方显示，带一点暖色微光
                ctx.fillText("别怕，雨再大有我呢", 0, -65);
                
                ctx.restore();
            }

            requestAnimationFrame(animate);
        }

        window.addEventListener('resize', resize);

        window.addEventListener('mousemove', (e) => {
            mouse.x = e.clientX;
            mouse.y = e.clientY;
            mouse.active = true;
        });

        window.addEventListener('touchmove', (e) => {
            e.preventDefault(); 
            mouse.x = e.touches[0].clientX;
            mouse.y = e.touches[0].clientY;
            mouse.active = true;
        }, { passive: false });

        window.addEventListener('touchend', () => {
            mouse.active = false; 
        });
        
        init();

    </script>
</body>
</html>
