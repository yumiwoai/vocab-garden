<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>璀璨星雨</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: #020205; /* 更深邃的背景 */
        }
        canvas {
            display: block;
        }
        .overlay {
            position: absolute;
            top: 20px;
            left: 20px;
            color: rgba(255, 255, 255, 0.8);
            font-family: 'Segoe UI', sans-serif;
            pointer-events: none;
            user-select: none;
            z-index: 10;
            text-shadow: 0 0 15px rgba(255,255,255,0.5);
        }
    </style>
</head>
<body>

    <div class="overlay">
        <h1 class="text-3xl font-light tracking-widest text-cyan-100 mb-1" style="text-shadow: 0 0 20px cyan;">STARFALL</h1>
        <p class="text-xs tracking-wider opacity-80">移动鼠标汇聚星光 · 点击切换星系</p>
    </div>

    <canvas id="canvas1"></canvas>

    <script>
        const canvas = document.getElementById('canvas1');
        const ctx = canvas.getContext('2d');

        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        // 配置参数
        const config = {
            rainCount: 3500,      // 大幅增加粒子数量，让雨更大
            splashCount: 6,       // 增加溅射数量，配合大雨
            mouseRadius: 120,     // 增大交互半径
            gravity: 0.2,         
        };

        // 颜色主题 - 更明亮、高饱和度的颜色
        const themes = [
            { name: "Electric Blue", r: 60, g: 200, b: 255, glow: 'cyan' },
            { name: "Neon Magenta", r: 255, g: 50, b: 200, glow: 'magenta' },
            { name: "Cyber Green", r: 50, g: 255, b: 100, glow: 'lime' },
            { name: "Solar Gold", r: 255, g: 220, b: 100, glow: 'gold' }
        ];
        let currentThemeIndex = 0;

        // 鼠标状态
        const mouse = {
            x: -1000,
            y: -1000,
            isActive: false
        };

        // 粒子容器
        let rainDrops = [];
        let splashes = [];

        // --- 类定义 ---

        // 雨滴类
        class RainDrop {
            constructor() {
                this.init(true);
            }

            init(randomY = false) {
                this.x = Math.random() * canvas.width;
                this.y = randomY ? Math.random() * canvas.height : -100;
                
                this.z = Math.random(); 
                
                // 速度稍快，增加动感
                this.speed = 5 + this.z * 8;
                this.length = 8 + this.z * 15;
                // 透明度更高，看起来更亮
                this.opacity = 0.4 + this.z * 0.6;
                this.width = 1 + this.z * 1.5;
                
                this.velocityX = 0;
            }

            update() {
                this.y += this.speed;
                this.x += this.velocityX;
                this.velocityX *= 0.9;

                if (mouse.isActive) {
                    const dx = this.x - mouse.x;
                    const dy = this.y - mouse.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);

                    if (distance < config.mouseRadius) {
                        if (dy < 0 && distance < config.mouseRadius * 0.8) { 
                            createSplash(this.x, this.y, this.z);
                            this.init();
                            return;
                        } else {
                            const angle = Math.atan2(dy, dx);
                            const force = (config.mouseRadius - distance) / config.mouseRadius;
                            this.velocityX += Math.cos(angle) * force * 5;
                            // 鼠标下方也稍微加速下落
                            if (dy > 0) this.speed += force * 2;
                        }
                    }
                }

                if (this.y > canvas.height) {
                    if (Math.random() > 0.3) { 
                         createSplash(this.x, canvas.height, this.z);
                    }
                    this.init();
                }
            }

            draw() {
                ctx.beginPath();
                ctx.moveTo(this.x, this.y);
                ctx.lineTo(this.x, this.y + this.length);
                
                const t = themes[currentThemeIndex];
                ctx.strokeStyle = `rgba(${t.r},${t.g},${t.b}, ${this.opacity})`;
                ctx.lineWidth = this.width;
                ctx.lineCap = 'round';
                
                // 添加发光效果
                ctx.shadowBlur = 10 * this.z + 5;
                ctx.shadowColor = t.glow;
                
                ctx.stroke();
                
                // 重置 shadowBlur，避免影响其他绘制
                ctx.shadowBlur = 0;
            }
        }

        // 溅射粒子类
        class SplashParticle {
            constructor(x, y, z) {
                this.x = x;
                this.y = y;
                this.z = z;
                this.speedX = (Math.random() - 0.5) * 8; // 溅射范围更大
                this.speedY = -(Math.random() * 5 + 2);  // 溅射更高
                this.life = 1.0;
                this.decay = Math.random() * 0.02 + 0.015;
                this.size = Math.random() * 2 + 1; // 粒子更大
            }

            update() {
                this.x += this.speedX;
                this.y += this.speedY;
                this.speedY += config.gravity * 1.5;
                this.life -= this.decay;
            }

            draw() {
                const t = themes[currentThemeIndex];
                // 溅射粒子更亮
                ctx.fillStyle = `rgba(${t.r},${t.g},${t.b}, ${this.life})`;
                
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                
                // 添加发光效果
                ctx.shadowBlur = 15 * this.life;
                ctx.shadowColor = t.glow;
                
                ctx.fill();
                ctx.shadowBlur = 0;
            }
        }

        // --- 功能函数 ---

        function createSplash(x, y, z) {
            if (z < 0.2) return;
            for (let i = 0; i < config.splashCount; i++) {
                splashes.push(new SplashParticle(x, y, z));
            }
        }

        function init() {
            rainDrops = [];
            splashes = [];
            for (let i = 0; i < config.rainCount; i++) {
                rainDrops.push(new RainDrop());
            }
        }

        function animate() {
            // 关键修改：使用半透明黑色填充，创造拖尾效果
            ctx.fillStyle = 'rgba(2, 2, 5, 0.2)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // 鼠标交互光晕增强
            if (mouse.isActive) {
                const t = themes[currentThemeIndex];
                const gradient = ctx.createRadialGradient(mouse.x, mouse.y, 0, mouse.x, mouse.y, config.mouseRadius * 1.2);
                gradient.addColorStop(0, `rgba(${t.r},${t.g},${t.b}, 0.1)`);
                gradient.addColorStop(0.5, `rgba(${t.r},${t.g},${t.b}, 0.2)`);
                gradient.addColorStop(1, `rgba(${t.r},${t.g},${t.b}, 0.0)`);
                
                // 鼠标中心的光点
                ctx.beginPath();
                ctx.arc(mouse.x, mouse.y, 5, 0, Math.PI*2);
                ctx.fillStyle = `rgba(${t.r},${t.g},${t.b}, 0.8)`;
                ctx.shadowBlur = 20;
                ctx.shadowColor = t.glow;
                ctx.fill();
                ctx.shadowBlur = 0;

                // 光晕圈
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(mouse.x, mouse.y, config.mouseRadius * 1.2, 0, Math.PI * 2);
                ctx.fill();
            }

            for (let i = 0; i < rainDrops.length; i++) {
                rainDrops[i].update();
                rainDrops[i].draw();
            }

            for (let i = splashes.length - 1; i >= 0; i--) {
                splashes[i].update();
                splashes[i].draw();
                if (splashes[i].life <= 0) {
                    splashes.splice(i, 1);
                }
            }

            requestAnimationFrame(animate);
        }

        // --- 事件监听 ---

        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            init();
        });

        window.addEventListener('mousemove', e => {
            mouse.x = e.clientX;
            mouse.y = e.clientY;
            mouse.isActive = true;
        });

        window.addEventListener('touchmove', e => {
            mouse.x = e.touches[0].clientX;
            mouse.y = e.touches[0].clientY;
            mouse.isActive = true;
        }, {passive: true});

        window.addEventListener('mouseout', () => {
            mouse.isActive = false;
        });

        window.addEventListener('click', () => {
            currentThemeIndex = (currentThemeIndex + 1) % themes.length;
        });

        init();
        animate();

    </script>
</body>
</html>
